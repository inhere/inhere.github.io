<!doctype html><html lang=zh-Hans><head><meta charset=UTF-8><meta content="default-src 'self';font-src 'self' data:;img-src 'self' https://* data:;media-src 'self';style-src 'self';frame-src player.vimeo.com https://www.youtube-nocookie.com;connect-src 'self';script-src 'self' 'self'" http-equiv=Content-Security-Policy><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://inhere.github.io name=base><title>
Inhere's Site • git 使用记录</title><link href=https://inhere.github.io/icons/favicon.ico rel=icon type=image/png><link title="Inhere's Site - Atom Feed" href=https://inhere.github.io/atom.xml rel=alternate type=application/atom+xml><link href="https://inhere.github.io/custom_subset.css?h=0b9535a28bc3d5bf2321" rel=stylesheet><link href="https://inhere.github.io/main.css?h=045c365e19a4d50a64bb" rel=stylesheet><link href="https://inhere.github.io/custom.css?h=b0b090835487d694b863" rel=stylesheet><link href="https://inhere.github.io/skins/blue.css?h=a4dc1e94d3f5759784d2" rel=stylesheet><meta content="light dark" name=color-scheme><meta content="git 使用一些记录，常用命令和一些特殊选项…" name=description><meta content="git 使用一些记录，常用命令和一些特殊选项…" property=og:description><meta content="git 使用记录" property=og:title><meta content=article property=og:type><meta content=zh_CN property=og:locale><meta content=https://inhere.github.io/blog/2016/04-11-git-usage-records/ property=og:url><meta content="Inhere's Site" property=og:site_name><noscript><link href=https://inhere.github.io/no_js.css rel=stylesheet></noscript><script src=https://inhere.github.io/js/initializeTheme.min.js></script><script defer src=https://inhere.github.io/js/themeSwitcher.min.js></script><body><a href=#main-content id=skip-link>跳到内容</a><header><nav class=navbar><div class=nav-title><a class=home-title href=https://inhere.github.io/>Inhere's Site</a></div><div class=nav-navs><ul><li><a class="nav-links no-hover-padding" href=https://inhere.github.io/blog/>📝 Blog </a><li><a class="nav-links no-hover-padding" href=https://inhere.github.io/projects/>🚀 Projects </a><li><a class="nav-links no-hover-padding" href=https://inhere.github.io/collections/>📚 Collections </a><li><a class="nav-links no-hover-padding" href=https://inhere.github.io/tags/>🏷️ Tags </a><li><a class="nav-links no-hover-padding" href=https://inhere.github.io/archive/>🗄️ Archive </a><li><a class="nav-links no-hover-padding" href=https://github.com/inhere>🐱 Github </a><li class=menu-icons-container><ul class=menu-icons-group><li class="theme-switcher-wrapper js"><div aria-label=切换到暗模式 aria-pressed=false class=theme-switcher role=button tabindex=0 title=切换到暗/亮模式></div><div class="theme-resetter arrow" aria-hidden=true aria-label=将模式重置为网站默认值 role=button tabindex=0 title=将模式重置为网站默认值></div></ul></ul></div></nav></header><div class=content id=main-content><main><article class=h-entry><h1 class="p-name article-title">git 使用记录</h1><a class="u-url u-uid" href=https://inhere.github.io/blog/2016/04-11-git-usage-records/></a><ul class=meta><li>由<span class=p-author>inhere</span>和<span class=p-author>network</span><li><time class=dt-published datetime=2016-04-11T16:51:34><span aria-hidden=true class=separator>•</span>11 4月 2016</time><li title="1635 字"><span aria-hidden=true class=separator>•</span>9 分钟阅读<li class=tag><span aria-hidden=true class=separator>•</span>标签: <li class=tag><a class=p-category href=https://inhere.github.io/tags/git/>git</a></ul><section class="e-content body"><p><code>git</code> 使用一些记录，常用命令和一些特殊选项</p><span id=continue-reading></span><h2 id=pullhe-merge><a aria-label="Anchor link for: pullhe-merge" class="header-anchor no-hover-padding" href=#pullhe-merge><span aria-hidden=true class=link-icon></span></a> pull和merge</h2><p>提倡添加选项 <code>--no-ff</code> – <em>不使用快速合并</em><h2 id=wen-jian-quan-xian-xiu-gai-yin-qi-de-chong-tu><a aria-label="Anchor link for: wen-jian-quan-xian-xiu-gai-yin-qi-de-chong-tu" class="header-anchor no-hover-padding" href=#wen-jian-quan-xian-xiu-gai-yin-qi-de-chong-tu><span aria-hidden=true class=link-icon></span></a> 文件权限修改引起的冲突</h2><p>通常是因为开发环境和运行环境是不同的系统，发布项目到线上时，很多时候需要修改文件的权限。但git把文件权限也列入了版本管理。<h3 id=jie-jue-ban-fa><a aria-label="Anchor link for: jie-jue-ban-fa" class="header-anchor no-hover-padding" href=#jie-jue-ban-fa><span aria-hidden=true class=link-icon></span></a> 解决办法：</h3><p>git中可以加入忽略文件权限的配置，具体如下：<pre class=z-code><code><span class="z-text z-plain">$ git config core.filemode false // 仅对当前项目有效
</span><span class="z-text z-plain">$ git config --global core.filemode false // 将配置应用到全局
</span></code></pre><p>这样就设置了忽略文件权限。查看下配置：<pre class=z-code><code><span class="z-text z-plain">$ git config -l
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">alias.co=checkout
</span><span class="z-text z-plain">alias.br=branch
</span><span class="z-text z-plain">core.filemode=false
</span><span class="z-text z-plain">core.repositoryformatversion=0
</span></code></pre><h2 id=gitda-tag><a aria-label="Anchor link for: gitda-tag" class="header-anchor no-hover-padding" href=#gitda-tag><span aria-hidden=true class=link-icon></span></a> Git打TAG</h2><blockquote><p>打TAG也就是发布版本</blockquote><pre class=z-code><code><span class="z-text z-plain">$ git tag -a v1.2 -m "version 1.4"
</span><span class="z-text z-plain">$ git push --tags
</span></code></pre><h2 id=gitda-bao-yuan-ma><a aria-label="Anchor link for: gitda-bao-yuan-ma" class="header-anchor no-hover-padding" href=#gitda-bao-yuan-ma><span aria-hidden=true class=link-icon></span></a> Git打包源码</h2><p>对Git管理的源码进行压缩打包，如果使用<code>tar xvzf xxxx.tag.gz xxxxx</code>的话并不是一个很好的选择，因为会将<code>.git/</code>目录下的中间文件全部压缩，如果只想要某一个版本的源码。 Git提供了<code>archive</code> 它会给打包一份纯净的代码。当然这个只适用于发部一个版本的源码，而不是备份Git管理的整套源码。<pre class=z-code><code><span class="z-text z-plain">$ git archive xxxx
</span></code></pre><blockquote><p>xxx代表SHA-1 Hash值。</blockquote><h2 id=gitzhi-clonezui-xin-ban-ben-dai-ma-bu-yao-gitmu-lu><a aria-label="Anchor link for: gitzhi-clonezui-xin-ban-ben-dai-ma-bu-yao-gitmu-lu" class="header-anchor no-hover-padding" href=#gitzhi-clonezui-xin-ban-ben-dai-ma-bu-yao-gitmu-lu><span aria-hidden=true class=link-icon></span></a> Git只clone最新版本代码不要.git目录</h2><pre class=z-code><code><span class="z-text z-plain">git clone --depth=1 git://someserver/somerepo dirformynewrepo
</span><span class="z-text z-plain">rm -rf !$/.git
</span></code></pre><h2 id=bu-chan-sheng-merge-commit><a aria-label="Anchor link for: bu-chan-sheng-merge-commit" class="header-anchor no-hover-padding" href=#bu-chan-sheng-merge-commit><span aria-hidden=true class=link-icon></span></a> 不产生 merge commit</h2><p>通常 <code>merge/pull</code> 会产生一个 merge commit,让提交记录看起来不太美观，可以使用 <code>rebase</code>选项来合并commit<pre class=z-code><code><span class="z-text z-plain">$ git pull --rebase origin master
</span></code></pre><h2 id=he-bing-shi-zhi-chan-sheng-he-bing-ti-jiao><a aria-label="Anchor link for: he-bing-shi-zhi-chan-sheng-he-bing-ti-jiao" class="header-anchor no-hover-padding" href=#he-bing-shi-zhi-chan-sheng-he-bing-ti-jiao><span aria-hidden=true class=link-icon></span></a> 合并时只产生合并提交</h2><blockquote><p>还有其它说法：合并时不合并历史；合并时将所有commit合为一个。</blockquote><pre class=z-code><code><span class="z-text z-plain">git pull --squash another
</span></code></pre><p>一般用于master分支，像linus的linux内核一样。 更多信息见《Git merge no history commit》《git merge –squash介绍》<h2 id=tian-jia-kong-mu-lu><a aria-label="Anchor link for: tian-jia-kong-mu-lu" class="header-anchor no-hover-padding" href=#tian-jia-kong-mu-lu><span aria-hidden=true class=link-icon></span></a> 添加空目录</h2><pre class=z-code><code><span class="z-text z-plain">$ find . -type d -empty -exec touch {}/.gitkeep \;
</span></code></pre><p>执行以上命令将会在空目录中添加一个<code>.gitkeep</code>文件，这样就可以保证空目录不被忽略，且不影响原代码的结构。<p>以上参考转自 <a rel="noopener nofollow noreferrer" class=external href=http://blog.csdn.net/kangear/article/details/13169395 target=_blank>Git深度使用经验总结</a><h2 id=shu-chu-zui-hou-yi-ci-ti-jiao-de-gai-bian><a aria-label="Anchor link for: shu-chu-zui-hou-yi-ci-ti-jiao-de-gai-bian" class="header-anchor no-hover-padding" href=#shu-chu-zui-hou-yi-ci-ti-jiao-de-gai-bian><span aria-hidden=true class=link-icon></span></a> 输出最后一次提交的改变</h2><p>这个命令，我经常使用它 来发送其他没有使用git的人来检查或者集成所修改的。它会输出最近提交的修改内容到一个zip文件中。<pre class=z-code><code><span class="z-text z-plain">git archive -o ../updated.zip HEAD $(git diff --name-only HEAD^)
</span></code></pre><h2 id=shu-chu-liang-ge-ti-jiao-jian-de-gai-bian><a aria-label="Anchor link for: shu-chu-liang-ge-ti-jiao-jian-de-gai-bian" class="header-anchor no-hover-padding" href=#shu-chu-liang-ge-ti-jiao-jian-de-gai-bian><span aria-hidden=true class=link-icon></span></a> 输出两个提交间的改变</h2><p>类似的，如果你需要输出某两个提交间的改变时，你可以使用这个。<pre class=z-code><code><span class="z-text z-plain">git archive -o ../latest.zip NEW_COMMIT_ID_HERE $(git diff --name-only OLD_COMMIT_ID_HERE NEW_COMMIT_ID_HERE)
</span></code></pre><h2 id=ke-long-zhi-ding-de-yuan-cheng-fen-zhi><a aria-label="Anchor link for: ke-long-zhi-ding-de-yuan-cheng-fen-zhi" class="header-anchor no-hover-padding" href=#ke-long-zhi-ding-de-yuan-cheng-fen-zhi><span aria-hidden=true class=link-icon></span></a> 克隆 指定的远程分支</h2><p>如果你渴望只克隆远程仓库的一个指定分支，而不是整个仓库分支，这对你帮助很大。<pre class=z-code><code><span class="z-text z-plain">git init
</span><span class="z-text z-plain">git remote add -t BRANCH_NAME_HERE -f origin REMOTE_REPO_URL_PATH_HERE
</span><span class="z-text z-plain">git checkout BRANCH_NAME_HERE
</span></code></pre><h2 id=ying-yong-cong-bu-xiang-guan-de-ben-di-cang-ku-lai-de-bu-ding><a aria-label="Anchor link for: ying-yong-cong-bu-xiang-guan-de-ben-di-cang-ku-lai-de-bu-ding" class="header-anchor no-hover-padding" href=#ying-yong-cong-bu-xiang-guan-de-ben-di-cang-ku-lai-de-bu-ding><span aria-hidden=true class=link-icon></span></a> 应用 从不相关的本地仓库来的补丁</h2><p>如果你需要其它一些不相关的本地仓库作为你现在仓库的补丁，这里就是通往那里的捷径。<pre class=z-code><code><span class="z-text z-plain">git --git-dir=PATH_TO_OTHER_REPOSITORY_HERE/.git format-patch -k -1 --stdout COMMIT_HASH_ID_HERE| git am -3 -k
</span></code></pre><h2 id=jian-ce-ni-de-fen-zhi-de-gai-bian-shi-fou-wei-qi-ta-fen-zhi-de-yi-bu-fen><a aria-label="Anchor link for: jian-ce-ni-de-fen-zhi-de-gai-bian-shi-fou-wei-qi-ta-fen-zhi-de-yi-bu-fen" class="header-anchor no-hover-padding" href=#jian-ce-ni-de-fen-zhi-de-gai-bian-shi-fou-wei-qi-ta-fen-zhi-de-yi-bu-fen><span aria-hidden=true class=link-icon></span></a> 检测 你的分支的改变是否为其它分支的一部分</h2><p><code>cherry</code>命令让我们检测你的分支的改变是否出现在其它一些分支中。它通过+或者-符号来显示从当前分支与所给的分支之间的改变：是否合并了(merged)。.+ 指示没有出现在所给分支中，反之，- 就表示出现在了所给的分支中了。这里就是如何去检测：<pre class=z-code><code><span class="z-text z-plain">git cherry -v OTHER_BRANCH_NAME_HERE
</span><span class="z-text z-plain"># 例如: 检测master分支
</span><span class="z-text z-plain">git cherry -v master
</span></code></pre><h2 id=kai-shi-yi-ge-wu-li-shi-de-xin-fen-zhi><a aria-label="Anchor link for: kai-shi-yi-ge-wu-li-shi-de-xin-fen-zhi" class="header-anchor no-hover-padding" href=#kai-shi-yi-ge-wu-li-shi-de-xin-fen-zhi><span aria-hidden=true class=link-icon></span></a> 开始一个无历史的新分支</h2><p>有时，你需要开始一个新分支，但是又不想把很长很长的历史记录带进来，例如，你想在公众区域（开源）放置你的代码，但是又不想别人知道它的历史记录。<pre class=z-code><code><span class="z-text z-plain">git checkout --orphan NEW_BRANCH_NAME_HERE
</span></code></pre><h2 id=wu-qie-huan-fen-zhi-de-cong-qi-ta-fen-zhi-checkoutwen-jian><a aria-label="Anchor link for: wu-qie-huan-fen-zhi-de-cong-qi-ta-fen-zhi-checkoutwen-jian" class="header-anchor no-hover-padding" href=#wu-qie-huan-fen-zhi-de-cong-qi-ta-fen-zhi-checkoutwen-jian><span aria-hidden=true class=link-icon></span></a> 无切换分支的从其它分支Checkout文件</h2><p>不想切换分支，但是又想从其它分支中获得你需要的文件：<pre class=z-code><code><span class="z-text z-plain">git checkout BRANCH_NAME_HERE -- PATH_TO_FILE_IN_BRANCH_HERE
</span></code></pre><h2 id=hu-lue-yi-zhui-zong-wen-jian-de-bian-dong><a aria-label="Anchor link for: hu-lue-yi-zhui-zong-wen-jian-de-bian-dong" class="header-anchor no-hover-padding" href=#hu-lue-yi-zhui-zong-wen-jian-de-bian-dong><span aria-hidden=true class=link-icon></span></a> 忽略已追踪文件的变动</h2><p>如果您正在一个团队中工作，而且大家都在同一条branch上面工作，那么您很有可能会经常用到fetch和merge。但是有时候这样会重置您的环境配置文件，如此的话，您就得在每次merge后修改它。使用这一命令，您就能要求git忽视指定文件的变动。这样，下回你再merge的话，这个文件就不会被修改了。<pre class=z-code><code><span class="z-text z-plain">git update-index --assume-unchanged PATH_TO_FILE_HERE
</span></code></pre><h2 id=jian-cha-ti-jiao-de-bian-dong-shi-fou-shi-releasede-yi-bu-fen><a aria-label="Anchor link for: jian-cha-ti-jiao-de-bian-dong-shi-fou-shi-releasede-yi-bu-fen" class="header-anchor no-hover-padding" href=#jian-cha-ti-jiao-de-bian-dong-shi-fou-shi-releasede-yi-bu-fen><span aria-hidden=true class=link-icon></span></a> 检查提交的变动是否是release的一部分</h2><p>name-rev命令能告诉您一个commit相对于最近一次release的位置。使用这条命令，您就可以检查您所做出的改动是否是release的一部分了。<pre class=z-code><code><span class="z-text z-plain">git name-rev --name-only COMMIT_HASH_HERE
</span></code></pre><h2 id=shi-yong-rebasetui-song-er-fei-merge><a aria-label="Anchor link for: shi-yong-rebasetui-song-er-fei-merge" class="header-anchor no-hover-padding" href=#shi-yong-rebasetui-song-er-fei-merge><span aria-hidden=true class=link-icon></span></a> 使用rebase推送而非merge</h2><p>如果您正在团队中工作并且整个团队都在同一条branch上面工作，那么您就得经常地进行fetch/merge或者pull。Git中，分支的合并以所提交的merge来记录，以此表明一条feature分支何时与主分支合并。但是在多团队成员共同工作于一条branch的情形中，常规的merge会导致log中出现多条消息，从而产生混淆。因此，您可以在pull的时候使用rebase，以此来减少无用的merge消息，从而保持历史记录的清晰。<pre class=z-code><code><span class="z-text z-plain">git pull --rebase
</span></code></pre><p>您也可以将某条branch配置为总是使用rebase推送：<pre class=z-code><code><span class="z-text z-plain">git config branch.BRANCH_NAME_HERE.rebase true
</span></code></pre><h2 id=git-revert-hou-zai-ci-mergedai-ma-diu-shi-wen-ti><a aria-label="Anchor link for: git-revert-hou-zai-ci-mergedai-ma-diu-shi-wen-ti" class="header-anchor no-hover-padding" href=#git-revert-hou-zai-ci-mergedai-ma-diu-shi-wen-ti><span aria-hidden=true class=link-icon></span></a> Git revert 后再次Merge代码丢失问题</h2><p>解决Git Revert操作后再次Merge代码被冲掉的问题。<h3 id=chan-sheng-guo-cheng><a aria-label="Anchor link for: chan-sheng-guo-cheng" class="header-anchor no-hover-padding" href=#chan-sheng-guo-cheng><span aria-hidden=true class=link-icon></span></a> 产生过程</h3><ul><li>开发分支Dev 错误的PR合并到了 目标分支A<li>使用 <code>git revert</code> 撤销了这次 PR 合并<li>后面想真正将 分支Dev 合并到 分支A 时，却发现没有第一次PR的代码</ul><h3 id=jie-jue-fang-shi-1><a aria-label="Anchor link for: jie-jue-fang-shi-1" class="header-anchor no-hover-padding" href=#jie-jue-fang-shi-1><span aria-hidden=true class=link-icon></span></a> 解决方式1：</h3><ul><li>删除现有的 目标分支A<li>从 Master 重新切一个目标分支A<li>将开发分支Dev合并到目标分支A</ul><h3 id=jie-jue-fang-shi-2><a aria-label="Anchor link for: jie-jue-fang-shi-2" class="header-anchor no-hover-padding" href=#jie-jue-fang-shi-2><span aria-hidden=true class=link-icon></span></a> 解决方式2：</h3><p>对 revert 的那次提交记录再次进行revert (官方推荐方法)<pre class="language-bash z-code" data-lang=bash><code class=language-bash data-lang=bash><span class="z-source z-shell z-bash"><span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">git</span></span><span class="z-meta z-function-call z-arguments z-shell"> checkout A</span>
</span><span class="z-source z-shell z-bash"><span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">git</span></span><span class="z-meta z-function-call z-arguments z-shell"> log</span>
</span><span class="z-source z-shell z-bash">
</span><span class="z-source z-shell z-bash"><span class="z-comment z-line z-number-sign z-shell"><span class="z-punctuation z-definition z-comment z-begin z-shell">#</span></span><span class="z-comment z-line z-number-sign z-shell"> 找到 revert 的那条提交记录</span><span class="z-comment z-line z-number-sign z-shell">
</span></span><span class="z-source z-shell z-bash"><span class="z-comment z-line z-number-sign z-shell"><span class="z-punctuation z-definition z-comment z-begin z-shell">#</span></span><span class="z-comment z-line z-number-sign z-shell"> 注意: revert 相关的会有两条记录</span><span class="z-comment z-line z-number-sign z-shell">
</span></span><span class="z-source z-shell z-bash"><span class="z-comment z-line z-number-sign z-shell"><span class="z-punctuation z-definition z-comment z-begin z-shell">#</span></span><span class="z-comment z-line z-number-sign z-shell">  第一条是 revert，第二条是 revert 后 merge 的记录，这里取第一条</span><span class="z-comment z-line z-number-sign z-shell">
</span></span><span class="z-source z-shell z-bash">
</span><span class="z-source z-shell z-bash"><span class="z-comment z-line z-number-sign z-shell"><span class="z-punctuation z-definition z-comment z-begin z-shell">#</span></span><span class="z-comment z-line z-number-sign z-shell"> revert之前的revert第一条commit_id</span><span class="z-comment z-line z-number-sign z-shell">
</span></span><span class="z-source z-shell z-bash"><span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">git</span></span><span class="z-meta z-function-call z-arguments z-shell"> revert <span class="z-keyword z-operator z-assignment z-redirection z-shell">&lt;</span>commit_id<span class="z-keyword z-operator z-assignment z-redirection z-shell">></span>
</span></span></code></pre><h2 id=git-revert-he-git-resetde-qu-bie><a aria-label="Anchor link for: git-revert-he-git-resetde-qu-bie" class="header-anchor no-hover-padding" href=#git-revert-he-git-resetde-qu-bie><span aria-hidden=true class=link-icon></span></a> git revert 和 git reset的区别</h2><ul><li>git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit。<li>git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。</ul><p>在回滚这一操作上看，效果差不多。但是在日后继续merge以前的老版本时有区别。 因为git revert是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现，但是git reset是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入。<blockquote><p>refers: <a rel="noopener nofollow noreferrer" class=external href=http://www.oschina.net/translate/10-useful-advanced-git-commands target=_blank>10 个很有用的高级 Git 命令</a></blockquote></section></article></main><div id=button-container><div id=toc-floating-container><input class=toggle id=toc-toggle type=checkbox><label class=button for=toc-toggle id=toc-button title=切换目录><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M414.82-193.094q-18.044 0-30.497-12.32-12.453-12.319-12.453-30.036t12.453-30.086q12.453-12.37 30.497-12.37h392.767q17.237 0 29.927 12.487 12.69 12.486 12.69 30.203 0 17.716-12.69 29.919t-29.927 12.203H414.82Zm0-244.833q-18.044 0-30.497-12.487Q371.87-462.9 371.87-480.45t12.453-29.92q12.453-12.369 30.497-12.369h392.767q17.237 0 29.927 12.511 12.69 12.512 12.69 29.845 0 17.716-12.69 30.086-12.69 12.37-29.927 12.37H414.82Zm0-245.167q-18.044 0-30.497-12.32t-12.453-30.037q0-17.716 12.453-30.086 12.453-12.369 30.497-12.369h392.767q17.237 0 29.927 12.486 12.69 12.487 12.69 30.203 0 17.717-12.69 29.92-12.69 12.203-29.927 12.203H414.82ZM189.379-156.681q-32.652 0-55.878-22.829t-23.226-55.731q0-32.549 23.15-55.647 23.151-23.097 55.95-23.097 32.799 0 55.313 23.484 22.515 23.484 22.515 56.246 0 32.212-22.861 54.893-22.861 22.681-54.963 22.681Zm0-245.167q-32.652 0-55.878-23.134-23.226-23.135-23.226-55.623 0-32.487 23.467-55.517t56.12-23.03q32.102 0 54.721 23.288 22.62 23.288 22.62 55.775 0 32.488-22.861 55.364-22.861 22.877-54.963 22.877Zm-.82-244.833q-32.224 0-55.254-23.288-23.03-23.289-23.03-55.623 0-32.333 23.271-55.364 23.272-23.03 55.495-23.03 32.224 0 55.193 23.288 22.969 23.289 22.969 55.622 0 32.334-23.21 55.364-23.21 23.031-55.434 23.031Z"/></svg></label><div class=toc-content><div class=toc-container><ul><li><a href=https://inhere.github.io/blog/2016/04-11-git-usage-records/#pullhe-merge>pull和merge</a><li><a href=https://inhere.github.io/blog/2016/04-11-git-usage-records/#wen-jian-quan-xian-xiu-gai-yin-qi-de-chong-tu>文件权限修改引起的冲突</a> <ul><li><a href=https://inhere.github.io/blog/2016/04-11-git-usage-records/#jie-jue-ban-fa>解决办法：</a></ul><li><a href=https://inhere.github.io/blog/2016/04-11-git-usage-records/#gitda-tag>Git打TAG</a><li><a href=https://inhere.github.io/blog/2016/04-11-git-usage-records/#gitda-bao-yuan-ma>Git打包源码</a><li><a href=https://inhere.github.io/blog/2016/04-11-git-usage-records/#gitzhi-clonezui-xin-ban-ben-dai-ma-bu-yao-gitmu-lu>Git只clone最新版本代码不要.git目录</a><li><a href=https://inhere.github.io/blog/2016/04-11-git-usage-records/#bu-chan-sheng-merge-commit>不产生 merge commit</a><li><a href=https://inhere.github.io/blog/2016/04-11-git-usage-records/#he-bing-shi-zhi-chan-sheng-he-bing-ti-jiao>合并时只产生合并提交</a><li><a href=https://inhere.github.io/blog/2016/04-11-git-usage-records/#tian-jia-kong-mu-lu>添加空目录</a><li><a href=https://inhere.github.io/blog/2016/04-11-git-usage-records/#shu-chu-zui-hou-yi-ci-ti-jiao-de-gai-bian>输出最后一次提交的改变</a><li><a href=https://inhere.github.io/blog/2016/04-11-git-usage-records/#shu-chu-liang-ge-ti-jiao-jian-de-gai-bian>输出两个提交间的改变</a><li><a href=https://inhere.github.io/blog/2016/04-11-git-usage-records/#ke-long-zhi-ding-de-yuan-cheng-fen-zhi>克隆 指定的远程分支</a><li><a href=https://inhere.github.io/blog/2016/04-11-git-usage-records/#ying-yong-cong-bu-xiang-guan-de-ben-di-cang-ku-lai-de-bu-ding>应用 从不相关的本地仓库来的补丁</a><li><a href=https://inhere.github.io/blog/2016/04-11-git-usage-records/#jian-ce-ni-de-fen-zhi-de-gai-bian-shi-fou-wei-qi-ta-fen-zhi-de-yi-bu-fen>检测 你的分支的改变是否为其它分支的一部分</a><li><a href=https://inhere.github.io/blog/2016/04-11-git-usage-records/#kai-shi-yi-ge-wu-li-shi-de-xin-fen-zhi>开始一个无历史的新分支</a><li><a href=https://inhere.github.io/blog/2016/04-11-git-usage-records/#wu-qie-huan-fen-zhi-de-cong-qi-ta-fen-zhi-checkoutwen-jian>无切换分支的从其它分支Checkout文件</a><li><a href=https://inhere.github.io/blog/2016/04-11-git-usage-records/#hu-lue-yi-zhui-zong-wen-jian-de-bian-dong>忽略已追踪文件的变动</a><li><a href=https://inhere.github.io/blog/2016/04-11-git-usage-records/#jian-cha-ti-jiao-de-bian-dong-shi-fou-shi-releasede-yi-bu-fen>检查提交的变动是否是release的一部分</a><li><a href=https://inhere.github.io/blog/2016/04-11-git-usage-records/#shi-yong-rebasetui-song-er-fei-merge>使用rebase推送而非merge</a><li><a href=https://inhere.github.io/blog/2016/04-11-git-usage-records/#git-revert-hou-zai-ci-mergedai-ma-diu-shi-wen-ti>Git revert 后再次Merge代码丢失问题</a> <ul><li><a href=https://inhere.github.io/blog/2016/04-11-git-usage-records/#chan-sheng-guo-cheng>产生过程</a><li><a href=https://inhere.github.io/blog/2016/04-11-git-usage-records/#jie-jue-fang-shi-1>解决方式1：</a><li><a href=https://inhere.github.io/blog/2016/04-11-git-usage-records/#jie-jue-fang-shi-2>解决方式2：</a></ul><li><a href=https://inhere.github.io/blog/2016/04-11-git-usage-records/#git-revert-he-git-resetde-qu-bie>git revert 和 git reset的区别</a></ul></div></div></div><a class=no-hover-padding href=# id=top-button title=返回页面顶部> <svg viewbox="0 0 20 20" fill=currentColor><path d="M3.293 9.707a1 1 0 010-1.414l6-6a1 1 0 011.414 0l6 6a1 1 0 01-1.414 1.414L11 5.414V17a1 1 0 11-2 0V5.414L4.707 9.707a1 1 0 01-1.414 0z"/></svg> </a></div><span class=hidden id=copy-success> 已复制! </span><span class=hidden id=copy-init> 复制代码到剪贴板 </span><script defer src=https://inhere.github.io/js/copyCodeToClipboard.min.js></script></div><footer><section><nav class="socials nav-navs"><ul><li><a class="nav-links no-hover-padding social" rel="noopener noreferrer" href=https://inhere.github.io/atom.xml target=_blank> <img alt=feed loading=lazy src=https://inhere.github.io/social_icons/rss.svg title=feed> </a><li><a class="nav-links no-hover-padding social" rel="noopener noreferrer me" href=https://github.com/inhere/ target=_blank> <img alt=github loading=lazy src=https://inhere.github.io/social_icons/github.svg title=github> </a></ul></nav><nav class=nav-navs><small> <ul><li><a class="nav-links no-hover-padding" href=https://inhere.github.io/pages/about> 🐶 About </a><li><a class="nav-links no-hover-padding" href=https://github.com/gookit> 🐱 Gookit </a><li><a class="nav-links no-hover-padding" href=https://github.com/phppkg> 🐱 PHPPkg </a><li><a class="nav-links no-hover-padding" href=https://inhere.github.io/sitemap.xml> 📄 Sitemap </a></ul> </small></nav><div class=credits><small> 网站基于 <a rel="noopener noreferrer" href=https://www.getzola.org target=_blank>Zola</a> 和 <a rel="noopener noreferrer" href=https://github.com/welpo/tabi target=_blank>tabi</a> • <a rel="noopener noreferrer" href=https://github.com/inhere/inhere.github.io target=_blank> 查看原始码 </a></small></div></section></footer>