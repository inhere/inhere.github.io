<!doctype html><html lang=zh-Hans><head><meta charset=UTF-8><meta content="default-src 'self';font-src 'self' data:;img-src 'self' https://* data:;media-src 'self';style-src 'self';frame-src player.vimeo.com https://www.youtube-nocookie.com;connect-src 'self';script-src 'self' 'self'" http-equiv=Content-Security-Policy><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://inhere.github.io name=base><title>
Inhere's Site • Mysql的锁机制解读</title><link href=https://inhere.github.io/icons/favicon.ico rel=icon type=image/png><link title="Inhere's Site - Atom Feed" href=https://inhere.github.io/atom.xml rel=alternate type=application/atom+xml><link href="https://inhere.github.io/custom_subset.css?h=0b9535a28bc3d5bf2321" rel=stylesheet><link href="https://inhere.github.io/main.css?h=045c365e19a4d50a64bb" rel=stylesheet><link href="https://inhere.github.io/custom.css?h=b0b090835487d694b863" rel=stylesheet><link href="https://inhere.github.io/skins/blue.css?h=a4dc1e94d3f5759784d2" rel=stylesheet><meta content="light dark" name=color-scheme><meta content=Mysql的锁机制解读说明… name=description><meta content=Mysql的锁机制解读说明… property=og:description><meta content=Mysql的锁机制解读 property=og:title><meta content=article property=og:type><meta content=zh_CN property=og:locale><meta content=https://inhere.github.io/blog/2016/lock-intro-in-mysql/ property=og:url><meta content="Inhere's Site" property=og:site_name><noscript><link href=https://inhere.github.io/no_js.css rel=stylesheet></noscript><script src=https://inhere.github.io/js/initializeTheme.min.js></script><script defer src=https://inhere.github.io/js/themeSwitcher.min.js></script><body><a href=#main-content id=skip-link>跳到内容</a><header><nav class=navbar><div class=nav-title><a class=home-title href=https://inhere.github.io/>Inhere's Site</a></div><div class=nav-navs><ul><li><a class="nav-links no-hover-padding" href=https://inhere.github.io/blog/>📝 Blog </a><li><a class="nav-links no-hover-padding" href=https://inhere.github.io/projects/>🚀 Projects </a><li><a class="nav-links no-hover-padding" href=https://inhere.github.io/collections/>📚 Collections </a><li><a class="nav-links no-hover-padding" href=https://inhere.github.io/tags/>🏷️ Tags </a><li><a class="nav-links no-hover-padding" href=https://inhere.github.io/archive/>🗄️ Archive </a><li><a class="nav-links no-hover-padding" href=https://github.com/inhere>🐱 Github </a><li class=menu-icons-container><ul class=menu-icons-group><li class="theme-switcher-wrapper js"><div aria-label=切换到暗模式 aria-pressed=false class=theme-switcher role=button tabindex=0 title=切换到暗/亮模式></div><div class="theme-resetter arrow" aria-hidden=true aria-label=将模式重置为网站默认值 role=button tabindex=0 title=将模式重置为网站默认值></div></ul></ul></div></nav></header><div class=content id=main-content><main><article class=h-entry><h1 class="p-name article-title">Mysql的锁机制解读</h1><a class="u-url u-uid" href=https://inhere.github.io/blog/2016/lock-intro-in-mysql/></a><ul class=meta><span class="hidden p-author h-card"> <a class=u-url href=https://inhere.github.io rel=author title=Inhere>Inhere</a> </span><li><time class=dt-published datetime=2016-09-07T21:17:34>7 9月 2016</time><li title="2325 字"><span aria-hidden=true class=separator>•</span>12 分钟阅读<li class=tag><span aria-hidden=true class=separator>•</span>标签: <li class=tag><a class=p-category href=https://inhere.github.io/tags/mysql/>mysql</a>, <li class=tag><a class=p-category href=https://inhere.github.io/tags/lock/>lock</a></ul><section class="e-content body"><p>Mysql的锁机制解读说明</p><span id=continue-reading></span><h2 id=ji-ben-gai-nian><a aria-label="Anchor link for: ji-ben-gai-nian" class="header-anchor no-hover-padding" href=#ji-ben-gai-nian><span aria-hidden=true class=link-icon></span></a> 基本概念</h2><h3 id=gong-xiang-suo><a aria-label="Anchor link for: gong-xiang-suo" class="header-anchor no-hover-padding" href=#gong-xiang-suo><span aria-hidden=true class=link-icon></span></a> 共享锁</h3><p>共享锁的代号是<code>S</code>，是Share的缩写，共享锁的锁粒度是行或者元组（多个行）。一个事务获取了共享锁之后，可以对锁定范围内的数据<strong>执行读操作</strong>。<h3 id=pai-ta-suo><a aria-label="Anchor link for: pai-ta-suo" class="header-anchor no-hover-padding" href=#pai-ta-suo><span aria-hidden=true class=link-icon></span></a> 排它锁</h3><p>排它锁的代号是<code>X</code>，是eXclusive的缩写，排它锁的粒度与共享锁相同，也是行或者元组。一个事务获取了排它锁之后，可以对锁定范围内的数据<strong>执行写操作</strong>。<p>例：假设有两个事务t1和t2<p>如果事务t1获取了一个元组的共享锁，事务t2还可以立即获取这个元组的共享锁，但不能立即获取这个元组的排它锁（必须等到t1释放共享锁之后）。 如果事务t1获取了一个元组的排它锁，事务t2不能立即获取这个元组的排共享锁，也不能立即获取这个元组的排它锁（必须等到t1释放排它锁之后）。<h3 id=yi-xiang-suo><a aria-label="Anchor link for: yi-xiang-suo" class="header-anchor no-hover-padding" href=#yi-xiang-suo><span aria-hidden=true class=link-icon></span></a> 意向锁</h3><p>意向锁是<strong>一种表锁，锁定的粒度是整张表</strong>，分为**意向共享锁(IS)<strong>和</strong>意向排它锁(IX)**两类。<p>意向共享锁表示一个事务有意对数据上共享锁或者排它锁。“有意”这两个字表达的意思比较微妙，说的明白点就是指事务想干这个事但还没真去干。 举例说明下意向共享锁，比如一个事务t执行了这样一个语句：<code>select * from table lock in share model</code> ，如果这个语句执行成功，就对表table上了一个意向共享锁。 <code>lock in share model</code> 就是说事务t1在接下来要执行的语句中要获取S锁。如果t1的<code>select * from table lock in share model</code>执行成功，那么接下来t1应该可以畅通无阻的去执行只需要共享锁的语句了。<p>意向排它锁的含义同理可知，上例中要获取意向排它锁，可以使用<code>select * from table for update</code> 。<p><code>lock in share model</code> 和 <code>for update</code>这两个东西在数据率理论中还有个学名叫<strong>悲观锁</strong>，与悲观锁相对的当然还有乐观锁。大家可以看到各种锁都是成双成对出现的。关于悲观锁和乐观锁的问题暂且不表。<h3 id=suo-de-hu-chi-yu-jian-rong-guan-xi><a aria-label="Anchor link for: suo-de-hu-chi-yu-jian-rong-guan-xi" class="header-anchor no-hover-padding" href=#suo-de-hu-chi-yu-jian-rong-guan-xi><span aria-hidden=true class=link-icon></span></a> 锁的互斥与兼容关系</h3><p>锁和锁之间的关系，要么是相容的，要么是互斥的。 锁a和锁b相容是指：操作同样一组数据时，如果事务t1获取了锁a,另一个事务t2还可以获取锁b； 锁a和锁b互斥是指：操作同样一组数据时，如果事务t1获取了锁a，另一个事务t2在t1释放锁a之前无法获取锁b。<p>上面提到的共享锁、排它锁、意向共享锁、意向排它锁相互之前都是有兼容/互斥关系的，可以用一个兼容性矩阵表示(y表示兼容，n表示不兼容):<pre class=z-code><code><span class="z-text z-plain">    X    S    IX    IS
</span><span class="z-text z-plain">X  n     n    n     n
</span><span class="z-text z-plain">S  n     y    n     y
</span><span class="z-text z-plain">IX n     n    y     y
</span><span class="z-text z-plain">IS n     y    y     y
</span></code></pre><p>兼容性矩阵为什么是这个样子的？<p>X和S的相互关系在上文中解释过了，IX和IS的相互关系全部是兼容，这也很好理解，因为它们都只是“有意”，还处于YY阶段，没有真干，所以是可以兼容的； 剩下的就是X和IX，X和IS, S和IX， S和IS的关系了，我们可以由X和S的关系推导出这四组关系。<p>简单的说：X和IX的=X和X的关系。为什么呢？因为事务在获取IX锁后，接下来就有权利获取X锁。如果X和IX兼容的话，就会出现两个事务都获取了X锁的情况，这与我们已知的X与X互斥是矛盾的，所以X与IX只能是互斥关系。<p>其余的三组关系同理，可用同样的方式推导出来。<h2 id=mysqlyou-san-chong-suo-de-ji-bie-ye-ji-biao-ji-xing-ji><a aria-label="Anchor link for: mysqlyou-san-chong-suo-de-ji-bie-ye-ji-biao-ji-xing-ji" class="header-anchor no-hover-padding" href=#mysqlyou-san-chong-suo-de-ji-bie-ye-ji-biao-ji-xing-ji><span aria-hidden=true class=link-icon></span></a> MySQL有三种锁的级别：页级、表级、行级。</h2><p>MyISAM和MEMORY存储引擎采用的是<strong>表级锁（table-level locking）</strong>； BDB存储引擎采用的是<strong>页面锁（page-level locking）</strong>，但也支持表级锁； InnoDB存储引擎既支持<strong>行级锁（row-level locking）</strong>，也支持表级锁，但默认情况下是采用行级锁。<p>MySQL这3种锁的特性可大致归纳如下：<ul><li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。<li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。<li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</ul><h2 id=myisambiao-suo><a aria-label="Anchor link for: myisambiao-suo" class="header-anchor no-hover-padding" href=#myisambiao-suo><span aria-hidden=true class=link-icon></span></a> MyISAM表锁</h2><p>MyISAM存储引擎只支持表锁，是现在用得最多的存储引擎。<h3 id=1-cha-xun-biao-ji-suo-zheng-yong-qing-kuang><a aria-label="Anchor link for: 1-cha-xun-biao-ji-suo-zheng-yong-qing-kuang" class="header-anchor no-hover-padding" href=#1-cha-xun-biao-ji-suo-zheng-yong-qing-kuang><span aria-hidden=true class=link-icon></span></a> 1、查询表级锁争用情况</h3><p>可以通过检查table_locks_waited和table_locks_immediate状态变量来分析系统上的表锁定争夺： mysql> show status like ‘table%’; +———————–+———-+ | Variable_name | Value | +———————–+———-+ | Table_locks_immediate | 76939364 | | Table_locks_waited | 305089 | +———————–+———-+ 2 rows in set (0.00 sec)Table_locks_waited的值比较高，说明存在着较严重的表级锁争用情况。<h3 id=2-mysqlbiao-ji-suo-de-suo-mo-shi><a aria-label="Anchor link for: 2-mysqlbiao-ji-suo-de-suo-mo-shi" class="header-anchor no-hover-padding" href=#2-mysqlbiao-ji-suo-de-suo-mo-shi><span aria-hidden=true class=link-icon></span></a> 2、MySQL表级锁的锁模式</h3><p>MySQL的表级锁有两种模式：**表共享读锁（Table Read Lock）**和 <strong>表独占写锁（Table Write Lock）</strong>。<blockquote><p>MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁。</blockquote><p>所以对MyISAM表进行操作，会有以下情况：<p>a. 对MyISAM表的读操作（加读锁），不会阻塞其他进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其它进程的写操作。 b. 对MyISAM表的写操作（加写锁），会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其它进程的读写操作。<p>下面通过例子来进行验证以上观点。数据表gz_phone里有二百多万数据，字段id,phone,ua,day。现在同时用多个客户端同时对该表进行操作分析。<p>a、当我用客户端1进行一个比较长时间的读操作时，分别用客户端2进行读和写操作：<pre class=z-code><code><span class="z-text z-plain">
</span><span class="z-text z-plain">client1:
</span><span class="z-text z-plain">mysql>select count(*) from gz_phone group by ua;
</span><span class="z-text z-plain">75508 rows in set (3 min 15.87 sec) client2:
</span><span class="z-text z-plain">select id,phone from gz_phone limit 1000,10;
</span><span class="z-text z-plain">+——+——-+
</span><span class="z-text z-plain">| id | phone |
</span><span class="z-text z-plain">+——+——-+
</span><span class="z-text z-plain">| 1001 | 2222 |
</span><span class="z-text z-plain">| 1002 | 2222 |
</span><span class="z-text z-plain">| 1003 | 2222 |
</span><span class="z-text z-plain">| 1004 | 2222 |
</span><span class="z-text z-plain">| 1005 | 2222 |
</span><span class="z-text z-plain">| 1006 | 2222 |
</span><span class="z-text z-plain">| 1007 | 2222 |
</span><span class="z-text z-plain">| 1008 | 2222 |
</span><span class="z-text z-plain">| 1009 | 2222 |
</span><span class="z-text z-plain">| 1010 | 2222 |
</span><span class="z-text z-plain">+——+——-+
</span><span class="z-text z-plain">10 rows in set (0.01 sec)
</span><span class="z-text z-plain">mysql> update gz_phone set phone=’11111111111′where id=1001;
</span><span class="z-text z-plain">Query OK, 0 rows affected (2 min 57.88 sec)
</span><span class="z-text z-plain">Rows matched: 1 Changed: 0 Warnings: 0
</span></code></pre><p>说明当数据表有一个读锁时，其它进程的查询操作可以马上执行，但更新操作需等待读锁释放后才会执行。<p>b、当用客户端1进行一个较长时间的更新操作时，用客户端2,3分别进行读写操作：<pre class=z-code><code><span class="z-text z-plain">client1:
</span><span class="z-text z-plain">mysql> update gz_phone set phone=’11111111111′;
</span><span class="z-text z-plain">Query OK, 1671823 rows affected (3 min 4.03 sec)
</span><span class="z-text z-plain">Rows matched: 2212070 Changed: 1671823 Warnings: 0 client2:
</span><span class="z-text z-plain">mysql> select id,phone,ua,day from gz_phone limit 10;
</span><span class="z-text z-plain">+—-+——-+——————-+————+
</span><span class="z-text z-plain">| id | phone | ua | day |
</span><span class="z-text z-plain">+—-+——-+——————-+————+
</span><span class="z-text z-plain">| 1 | 2222 | SonyEricssonK310c | 2007-12-19 |
</span><span class="z-text z-plain">| 2 | 2222 | SonyEricssonK750c | 2007-12-19 |
</span><span class="z-text z-plain">| 3 | 2222 | MAUI WAP Browser | 2007-12-19 |
</span><span class="z-text z-plain">| 4 | 2222 | Nokia3108 | 2007-12-19 |
</span><span class="z-text z-plain">| 5 | 2222 | LENOVO-I750 | 2007-12-19 |
</span><span class="z-text z-plain">| 6 | 2222 | BIRD_D636 | 2007-12-19 |
</span><span class="z-text z-plain">| 7 | 2222 | SonyEricssonS500c | 2007-12-19 |
</span><span class="z-text z-plain">| 8 | 2222 | SAMSUNG-SGH-E258 | 2007-12-19 |
</span><span class="z-text z-plain">| 9 | 2222 | NokiaN73-1 | 2007-12-19 |
</span><span class="z-text z-plain">| 10 | 2222 | Nokia2610 | 2007-12-19 |
</span><span class="z-text z-plain">+—-+——-+——————-+————+
</span><span class="z-text z-plain">10 rows in set (2 min 58.56 sec) client3:
</span><span class="z-text z-plain">mysql> update gz_phone set phone=’55555′where id=1;
</span><span class="z-text z-plain">Query OK, 1 row affected (3 min 50.16 sec)
</span><span class="z-text z-plain">Rows matched: 1 Changed: 1 Warnings: 0
</span></code></pre><p>说明当数据表有一个写锁时，其它进程的读写操作都需等待读锁释放后才会执行。<h3 id=3-bing-fa-cha-ru><a aria-label="Anchor link for: 3-bing-fa-cha-ru" class="header-anchor no-hover-padding" href=#3-bing-fa-cha-ru><span aria-hidden=true class=link-icon></span></a> 3、并发插入</h3><p>原则上数据表有一个读锁时，其它进程无法对此表进行更新操作，但在一定条件下，MyISAM表也支持查询和插入操作的并发进行。<p>MyISAM存储引擎有一个系统变量concurrent_insert，专门用以控制其并发插入的行为，其值分别可以为0、1或2。<p>a. 当concurrent_insert设置为0时，不允许并发插入。 b. 当concurrent_insert设置为1时，如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录。这也是MySQL的默认设置。 c. 当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录。<h3 id=4-myisamde-suo-diao-du><a aria-label="Anchor link for: 4-myisamde-suo-diao-du" class="header-anchor no-hover-padding" href=#4-myisamde-suo-diao-du><span aria-hidden=true class=link-icon></span></a> 4、MyISAM的锁调度</h3><p>由于MySQL认为写请求一般比读请求要重要，所以如果有读写请求同时进行的话，MYSQL将会优先执行写操作。这样MyISAM表在进行大量的更新操作时（特别是更新的字段中存在索引的情况下），会造成查询操作很难获得读锁，从而导致查询阻塞。<p>我们可以通过一些设置来调节MyISAM的调度行为：<p>a. 通过指定启动参数<code>low-priority-updates</code>，使MyISAM引擎默认给予读请求以优先的权利。 b. 通过执行命令<code>SET LOW_PRIORITY_UPDATES=1</code>，使该连接发出的更新请求优先级降低。 c. 通过指定 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code> 语句的<code>LOW_PRIORITY</code>属性，降低该语句的优先级。<p>上面3种方法都是要么更新优先，要么查询优先的方法。这里要说明的就是，不要盲目的给mysql设置为读优先，因为一些需要长时间运行的查询操作，也会使写进程“饿死”。只有根据你的实际情况，来决定设置哪种操作优先。这些方法还是没有从根本上同时解决查询和更新的问题。<p>在一个有大数据量高并发表的mysql里，我们还可采用另一种策略来进行优化，那就是通过mysql主从（读写）分离来实现负载均衡，这样可避免优先哪一种操作从而可能导致另一种操作的堵塞。<blockquote><p>转自：<a rel="noopener nofollow noreferrer" class=external href=http://blog.csdn.net/andyxm/article/details/44810313 target=_blank>CSDN博客</a></blockquote></section></article></main><div id=button-container><div id=toc-floating-container><input class=toggle id=toc-toggle type=checkbox><label class=button for=toc-toggle id=toc-button title=切换目录><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M414.82-193.094q-18.044 0-30.497-12.32-12.453-12.319-12.453-30.036t12.453-30.086q12.453-12.37 30.497-12.37h392.767q17.237 0 29.927 12.487 12.69 12.486 12.69 30.203 0 17.716-12.69 29.919t-29.927 12.203H414.82Zm0-244.833q-18.044 0-30.497-12.487Q371.87-462.9 371.87-480.45t12.453-29.92q12.453-12.369 30.497-12.369h392.767q17.237 0 29.927 12.511 12.69 12.512 12.69 29.845 0 17.716-12.69 30.086-12.69 12.37-29.927 12.37H414.82Zm0-245.167q-18.044 0-30.497-12.32t-12.453-30.037q0-17.716 12.453-30.086 12.453-12.369 30.497-12.369h392.767q17.237 0 29.927 12.486 12.69 12.487 12.69 30.203 0 17.717-12.69 29.92-12.69 12.203-29.927 12.203H414.82ZM189.379-156.681q-32.652 0-55.878-22.829t-23.226-55.731q0-32.549 23.15-55.647 23.151-23.097 55.95-23.097 32.799 0 55.313 23.484 22.515 23.484 22.515 56.246 0 32.212-22.861 54.893-22.861 22.681-54.963 22.681Zm0-245.167q-32.652 0-55.878-23.134-23.226-23.135-23.226-55.623 0-32.487 23.467-55.517t56.12-23.03q32.102 0 54.721 23.288 22.62 23.288 22.62 55.775 0 32.488-22.861 55.364-22.861 22.877-54.963 22.877Zm-.82-244.833q-32.224 0-55.254-23.288-23.03-23.289-23.03-55.623 0-32.333 23.271-55.364 23.272-23.03 55.495-23.03 32.224 0 55.193 23.288 22.969 23.289 22.969 55.622 0 32.334-23.21 55.364-23.21 23.031-55.434 23.031Z"/></svg></label><div class=toc-content><div class=toc-container><ul><li><a href=https://inhere.github.io/blog/2016/lock-intro-in-mysql/#ji-ben-gai-nian>基本概念</a> <ul><li><a href=https://inhere.github.io/blog/2016/lock-intro-in-mysql/#gong-xiang-suo>共享锁</a><li><a href=https://inhere.github.io/blog/2016/lock-intro-in-mysql/#pai-ta-suo>排它锁</a><li><a href=https://inhere.github.io/blog/2016/lock-intro-in-mysql/#yi-xiang-suo>意向锁</a><li><a href=https://inhere.github.io/blog/2016/lock-intro-in-mysql/#suo-de-hu-chi-yu-jian-rong-guan-xi>锁的互斥与兼容关系</a></ul><li><a href=https://inhere.github.io/blog/2016/lock-intro-in-mysql/#mysqlyou-san-chong-suo-de-ji-bie-ye-ji-biao-ji-xing-ji>MySQL有三种锁的级别：页级、表级、行级。</a><li><a href=https://inhere.github.io/blog/2016/lock-intro-in-mysql/#myisambiao-suo>MyISAM表锁</a> <ul><li><a href=https://inhere.github.io/blog/2016/lock-intro-in-mysql/#1-cha-xun-biao-ji-suo-zheng-yong-qing-kuang>1、查询表级锁争用情况</a><li><a href=https://inhere.github.io/blog/2016/lock-intro-in-mysql/#2-mysqlbiao-ji-suo-de-suo-mo-shi>2、MySQL表级锁的锁模式</a><li><a href=https://inhere.github.io/blog/2016/lock-intro-in-mysql/#3-bing-fa-cha-ru>3、并发插入</a><li><a href=https://inhere.github.io/blog/2016/lock-intro-in-mysql/#4-myisamde-suo-diao-du>4、MyISAM的锁调度</a></ul></ul></div></div></div><a class=no-hover-padding href=# id=top-button title=返回页面顶部> <svg viewbox="0 0 20 20" fill=currentColor><path d="M3.293 9.707a1 1 0 010-1.414l6-6a1 1 0 011.414 0l6 6a1 1 0 01-1.414 1.414L11 5.414V17a1 1 0 11-2 0V5.414L4.707 9.707a1 1 0 01-1.414 0z"/></svg> </a></div><span class=hidden id=copy-success> 已复制! </span><span class=hidden id=copy-init> 复制代码到剪贴板 </span><script defer src=https://inhere.github.io/js/copyCodeToClipboard.min.js></script></div><footer><section><nav class="socials nav-navs"><ul><li><a class="nav-links no-hover-padding social" rel="noopener noreferrer" href=https://inhere.github.io/atom.xml target=_blank> <img alt=feed loading=lazy src=https://inhere.github.io/social_icons/rss.svg title=feed> </a><li><a class="nav-links no-hover-padding social" rel="noopener noreferrer me" href=https://github.com/inhere/ target=_blank> <img alt=github loading=lazy src=https://inhere.github.io/social_icons/github.svg title=github> </a></ul></nav><nav class=nav-navs><small> <ul><li><a class="nav-links no-hover-padding" href=https://inhere.github.io/pages/about> 🐶 About </a><li><a class="nav-links no-hover-padding" href=https://github.com/gookit> 🐱 Gookit </a><li><a class="nav-links no-hover-padding" href=https://github.com/phppkg> 🐱 PHPPkg </a><li><a class="nav-links no-hover-padding" href=https://inhere.github.io/sitemap.xml> 📄 Sitemap </a></ul> </small></nav><div class=credits><small> 网站基于 <a rel="noopener noreferrer" href=https://www.getzola.org target=_blank>Zola</a> 和 <a rel="noopener noreferrer" href=https://github.com/welpo/tabi target=_blank>tabi</a> • <a rel="noopener noreferrer" href=https://github.com/inhere/inhere.github.io target=_blank> 查看原始码 </a></small></div></section></footer>