<!doctype html>
<html lang="zh-CN" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.3">
<title data-rh="true">Nginx配置文件中的变量的编写使用 | Inhere&#x27;s Site</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://inhere.github.io/blog/custom-vars-usage-in-ngnix-config"><meta data-rh="true" name="docusaurus_locale" content="zh-CN"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="zh-CN"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="Nginx配置文件中的变量的编写使用 | Inhere&#x27;s Site"><meta data-rh="true" name="description" content="Nginx配置文件中的变量的编写使用,包括从常用的rewrite等方面来深入变量的相关定义,需要的朋友可以参考下"><meta data-rh="true" property="og:description" content="Nginx配置文件中的变量的编写使用,包括从常用的rewrite等方面来深入变量的相关定义,需要的朋友可以参考下"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2016-05-13T17:21:00.000Z"><meta data-rh="true" property="article:author" content="https://github.com/inhere"><meta data-rh="true" property="article:tag" content="ngnix"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://inhere.github.io/blog/custom-vars-usage-in-ngnix-config"><link data-rh="true" rel="alternate" href="https://inhere.github.io/blog/custom-vars-usage-in-ngnix-config" hreflang="zh-CN"><link data-rh="true" rel="alternate" href="https://inhere.github.io/en/blog/custom-vars-usage-in-ngnix-config" hreflang="en-GB"><link data-rh="true" rel="alternate" href="https://inhere.github.io/blog/custom-vars-usage-in-ngnix-config" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Inhere&#39;s Site RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Inhere&#39;s Site Atom Feed"><link rel="stylesheet" href="/assets/css/styles.a37d040a.css">
<link rel="preload" href="/assets/js/runtime~main.bfcef8ca.js" as="script">
<link rel="preload" href="/assets/js/main.616ec195.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a class="skipToContent_e0Pp" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top navbarHideable_zt9x"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/inhere-s03.png" alt="Inhere&#x27;s Site Logo" class="themedImage_eFkk themedImage--light_TSOd"><img src="/img/inhere-s03.png" alt="Inhere&#x27;s Site Logo" class="themedImage_eFkk themedImage--dark_tEvh"></div><b class="navbar__title text--truncate">Inhere&#x27;s Site</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a><a class="navbar__item navbar__link" href="/blog/tags">Tags</a><a class="navbar__item navbar__link" href="/docs/intro">Docs</a><a class="navbar__item navbar__link" href="/projects">Projects</a><a class="navbar__item navbar__link" href="/about">About</a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link"><svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" class="iconLanguage_WdOp"><path fill="currentColor" d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></svg>中文（中国）</a><ul class="dropdown__menu"><li><a href="/blog/custom-vars-usage-in-ngnix-config" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang="zh-CN">中文（中国）</a></li><li><a href="/en/blog/custom-vars-usage-in-ngnix-config" target="_self" rel="noopener noreferrer" class="dropdown__link" lang="en-GB">English</a></li></ul></div><a href="https://github.com/inhere" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_xZoC"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_cm5Z colorModeToggle_a24a"><button class="clean-btn toggleButton_hLpL toggleButtonDisabled_oHT3" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_KMtP"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_sC2x"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_hxMH"><div class="navbar__search searchBarContainer_e18z"><input placeholder="搜索" aria-label="Search" class="navbar__search-input"><div class="loadingRing_ztk1 searchBarLoadingRing_CaoD"><div></div><div></div><div></div><div></div></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_SBfI"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_RKtQ thin-scrollbar" aria-label="最近博文导航"><div class="sidebarItemTitle_FhMI margin-bottom--md">📅最近文章</div><ul class="sidebarItemList_UcJN clean-list"><li class="sidebarItem_410U"><a class="sidebarItemLink_Z50W" href="/blog/gookit-validate-release-v1.5.2">gookit validate release v1.5.2</a></li><li class="sidebarItem_410U"><a class="sidebarItemLink_Z50W" href="/blog/gookit-goutil-release-v0.6.15">gookit/goutil - Go常用功能的扩展工具库，发布 v0.6.15 版本</a></li><li class="sidebarItem_410U"><a class="sidebarItemLink_Z50W" href="/blog/gookit-goutil-release-v0.6.14">gookit/goutil - Go常用功能的扩展工具库，发布 v0.6.14 版本</a></li><li class="sidebarItem_410U"><a class="sidebarItemLink_Z50W" href="/blog/use-multi-version-php-on-windows">在Windows下使用多个版本的PHP记录</a></li><li class="sidebarItem_410U"><a class="sidebarItemLink_Z50W" href="/blog/gookit-goutil-release-v0.6.12">gookit/goutil - Go常用功能的扩展工具库，发布 v0.6.12 版本</a></li><li class="sidebarItem_410U"><a class="sidebarItemLink_Z50W" href="/blog/gookit-goutil-release-v0.6.10">gookit/goutil - 发布 v0.6.10 版本, Go常用功能的扩展工具库</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><meta itemprop="description" content="Nginx配置文件中的变量的编写使用,包括从常用的rewrite等方面来深入变量的相关定义,需要的朋友可以参考下"><header><h1 class="title_y9ha" itemprop="headline">Nginx配置文件中的变量的编写使用</h1><div class="container_El6s margin-vert--md"><time datetime="2016-05-13T17:21:00.000Z" itemprop="datePublished">2016年5月13日</time> · <!-- -->阅读需 26 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_ZYyr"><div class="avatar margin-bottom--sm"><a href="https://github.com/inhere" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://github.com/inhere.png" alt="inhere" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/inhere" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">inhere</span></a></div><small class="avatar__subtitle" itemprop="description">docs maintainer</small></div></div></div><div class="col col--6 authorCol_ZYyr"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><span itemprop="name">From Network</span></div><small class="avatar__subtitle" itemprop="description">Contents from network</small></div></div></div></div></header><div id="__blog-post-container" class="markdown" itemprop="articleBody"><p>Nginx配置文件中的变量的编写使用,包括从常用的rewrite等方面来深入变量的相关定义,需要的朋友可以参考下 </p><h2 class="anchor anchorWithHideOnScrollNavbar_vLxx" id="nginx-用户变量">Nginx 用户变量<a href="#nginx-用户变量" class="hash-link" aria-label="Nginx 用户变量的直接链接" title="Nginx 用户变量的直接链接">​</a></h2><p>nginx 的配置文件使用的就是一门微型的编程语言，许多真实世界里的 Nginx 配置文件其实就是一个一个的小程序。当然，是不是“图灵完全的”暂且不论，至少据我观察，它在设计上受 Perl 和 Bourne shell 这两种语言的影响很大。在这一点上，相比 Apache 和 Lighttpd 等其他 Web 服务器的配置记法，不能不说算是 Nginx 的一大特色了。既然是编程语言，一般也就少不了“变量”这种东西（当然，Haskell 这样奇怪的函数式语言除外了）。
熟悉 Perl、Bourne shell、C/C++ 等命令式编程语言的朋友肯定知道，变量说白了就是存放“值”的容器。而所谓“值”，在许多编程语言里，既可以是 3.14 这样的数值，也可以是 hello world 这样的字符串，甚至可以是像数组、哈希表这样的复杂数据结构。然而，在 Nginx 配置中，变量只能存放一种类型的值，因为也只存在一种类型的值，那就是字符串。
比如我们的 nginx.conf 文件中有下面这一行配置：</p><div class="codeBlockContainer_wGwY theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_S5yK"><pre tabindex="0" class="prism-code language-text codeBlock_DhuE thin-scrollbar"><code class="codeBlockLines_dNfr"><span class="token-line" style="color:#393A34"><span class="token plain">set $a &quot;hello world&quot;; </span><br></span></code></pre><div class="buttonGroup_ACW1"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_J8qt" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sp2o"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_AUya"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>我们使用了标准 ngx_rewrite 模块的 set 配置指令对变量 $a 进行了赋值操作。特别地，我们把字符串 hello world 赋给了它。
我们看到，Nginx 变量名前面有一个 $ 符号，这是记法上的要求。所有的 Nginx 变量在 Nginx 配置文件中引用时都须带上 $ 前缀。这种表示方法和 Perl、PHP 这些语言是相似的。
虽然 $ 这样的变量前缀修饰会让正统的 Java 和 C# 程序员不舒服，但这种表示方法的好处也是显而易见的，那就是可以直接把变量嵌入到字符串常量中以构造出新的字符串：</p><div class="codeBlockContainer_wGwY theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_S5yK"><pre tabindex="0" class="prism-code language-text codeBlock_DhuE thin-scrollbar"><code class="codeBlockLines_dNfr"><span class="token-line" style="color:#393A34"><span class="token plain">set $a hello;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">set $b &quot;$a, $a&quot;; </span><br></span></code></pre><div class="buttonGroup_ACW1"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_J8qt" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sp2o"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_AUya"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这里我们通过已有的 Nginx 变量 $a 的值，来构造变量 $b 的值，于是这两条指令顺序执行完之后，$a 的值是 hello，而 $b 的值则是 hello, hello. 这种技术在 Perl 世界里被称为“变量插值”（variable interpolation），它让专门的字符串拼接运算符变得不再那么必要。我们在这里也不妨采用此术语。
我们来看一个比较完整的配置示例：</p><div class="codeBlockContainer_wGwY theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_S5yK"><pre tabindex="0" class="prism-code language-text codeBlock_DhuE thin-scrollbar"><code class="codeBlockLines_dNfr"><span class="token-line" style="color:#393A34"><span class="token plain">server {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  listen 8080;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  location /test {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    set $foo hello;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    echo &quot;foo: $foo&quot;;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span><br></span></code></pre><div class="buttonGroup_ACW1"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_J8qt" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sp2o"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_AUya"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这个例子省略了 nginx.conf 配置文件中最外围的 http 配置块以及 events 配置块。使用 curl 这个 HTTP 客户端在命令行上请求这个 /test 接口，我们可以得到</p><div class="codeBlockContainer_wGwY theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_S5yK"><pre tabindex="0" class="prism-code language-text codeBlock_DhuE thin-scrollbar"><code class="codeBlockLines_dNfr"><span class="token-line" style="color:#393A34"><span class="token plain">$ curl &#x27;http://localhost:8080/test&#x27;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">foo: hello </span><br></span></code></pre><div class="buttonGroup_ACW1"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_J8qt" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sp2o"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_AUya"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这里我们使用第三方 ngx_echo 模块的 echo 配置指令将 $foo 变量的值作为当前请求的响应体输出。
我们看到，echo 配置指令的参数也支持“变量插值”。不过，需要说明的是，并非所有的配置指令都支持“变量插值”。事实上，指令参数是否允许“变量插值”，取决于该指令的实现模块。
如果我们想通过 echo 指令直接输出含有“美元符”（$）的字符串，那么有没有办法把特殊的 $ 字符给转义掉呢？答案是否定的（至少到目前最新的 Nginx 稳定版 1.0.10）。不过幸运的是，我们可以绕过这个限制，比如通过不支持“变量插值”的模块配置指令专门构造出取值为 $ 的 Nginx 变量，然后再在 echo 中使用这个变量。看下面这个例子：</p><div class="codeBlockContainer_wGwY theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_S5yK"><pre tabindex="0" class="prism-code language-text codeBlock_DhuE thin-scrollbar"><code class="codeBlockLines_dNfr"><span class="token-line" style="color:#393A34"><span class="token plain">geo $dollar {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  default &quot;$&quot;;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">server {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  listen 8080;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  location /test {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    echo &quot;This is a dollar sign: $dollar&quot;;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span><br></span></code></pre><div class="buttonGroup_ACW1"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_J8qt" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sp2o"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_AUya"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>测试结果如下：</p><div class="codeBlockContainer_wGwY theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_S5yK"><pre tabindex="0" class="prism-code language-text codeBlock_DhuE thin-scrollbar"><code class="codeBlockLines_dNfr"><span class="token-line" style="color:#393A34"><span class="token plain">$ curl &#x27;http://localhost:8080/test&#x27;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">This is a dollar sign: $ </span><br></span></code></pre><div class="buttonGroup_ACW1"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_J8qt" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sp2o"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_AUya"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这里用到了标准模块 ngx_geo 提供的配置指令 geo 来为变量 $dollar 赋予字符串 &quot;$&quot;，这样我们在下面需要使用美元符的地方，就直接引用我们的 $dollar 变量就可以了。其实 ngx_geo 模块最常规的用法是根据客户端的 IP 地址对指定的 Nginx 变量进行赋值，这里只是借用它以便“无条件地”对我们的 $dollar 变量赋予“美元符”这个值。
在“变量插值”的上下文中，还有一种特殊情况，即当引用的变量名之后紧跟着变量名的构成字符时（比如后跟字母、数字以及下划线），我们就需要使用特别的记法来消除歧义，例如：</p><div class="codeBlockContainer_wGwY theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_S5yK"><pre tabindex="0" class="prism-code language-text codeBlock_DhuE thin-scrollbar"><code class="codeBlockLines_dNfr"><span class="token-line" style="color:#393A34"><span class="token plain">server {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  listen 8080;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  location /test {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    set $first &quot;hello &quot;;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    echo &quot;${first}world&quot;;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span><br></span></code></pre><div class="buttonGroup_ACW1"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_J8qt" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sp2o"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_AUya"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这里，我们在 echo 配置指令的参数值中引用变量 $first 的时候，后面紧跟着 world 这个单词，所以如果直接写作 &quot;$firstworld&quot; 则 Nginx “变量插值”计算引擎会将之识别为引用了变量 $firstworld. 为了解决这个难题，Nginx 的字符串记法支持使用花括号在 $ 之后把变量名围起来，比如这里的 ${first}. 上面这个例子的输出是：</p><div class="codeBlockContainer_wGwY theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_S5yK"><pre tabindex="0" class="prism-code language-text codeBlock_DhuE thin-scrollbar"><code class="codeBlockLines_dNfr"><span class="token-line" style="color:#393A34"><span class="token plain">$ curl &#x27;http://localhost:8080/test  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">hello world </span><br></span></code></pre><div class="buttonGroup_ACW1"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_J8qt" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sp2o"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_AUya"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>set 指令（以及前面提到的 geo 指令）不仅有赋值的功能，它还有创建 Nginx 变量的副作用，即当作为赋值对象的变量尚不存在时，它会自动创建该变量。比如在上面这个例子中，如果 $a 这个变量尚未创建，则 set 指令会自动创建 $a 这个用户变量。如果我们不创建就直接使用它的值，则会报错。例如</p><div class="codeBlockContainer_wGwY theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_S5yK"><pre tabindex="0" class="prism-code language-text codeBlock_DhuE thin-scrollbar"><code class="codeBlockLines_dNfr"><span class="token-line" style="color:#393A34"><span class="token plain">server {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  listen 8080;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  location /bad {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    echo $foo;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> } </span><br></span></code></pre><div class="buttonGroup_ACW1"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_J8qt" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sp2o"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_AUya"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>此时 Nginx 服务器会拒绝加载配置:</p><div class="codeBlockContainer_wGwY theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_S5yK"><pre tabindex="0" class="prism-code language-text codeBlock_DhuE thin-scrollbar"><code class="codeBlockLines_dNfr"><span class="token-line" style="color:#393A34"><span class="token plain">[emerg] unknown &quot;foo&quot; variable</span><br></span></code></pre><div class="buttonGroup_ACW1"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_J8qt" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sp2o"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_AUya"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>是的，我们甚至都无法启动服务！</p><p>有趣的是，<strong>Nginx 变量的创建和赋值操作发生在全然不同的时间阶段</strong>。</p><ul><li>Nginx 变量的创建只能发生在 Nginx 配置加载的时候，或者说 Nginx 启动的时候；</li><li>赋值操作则只会发生在请求实际处理的时候。</li></ul><blockquote><p>这意味着不创建而直接使用变量会导致启动失败，同时也意味着我们无法在请求处理时动态地创建新的 Nginx 变量。</p></blockquote><p>Nginx 变量一旦创建，其变量名的可见范围就是整个 Nginx 配置，甚至可以跨越不同虚拟主机的 server 配置块。
我们来看一个例子：</p><div class="codeBlockContainer_wGwY theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_S5yK"><pre tabindex="0" class="prism-code language-text codeBlock_DhuE thin-scrollbar"><code class="codeBlockLines_dNfr"><span class="token-line" style="color:#393A34"><span class="token plain">server {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  listen 8080;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  location /foo {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    echo &quot;foo = [$foo]&quot;;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  location /bar {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    set $foo 32;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    echo &quot;foo = [$foo]&quot;;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span><br></span></code></pre><div class="buttonGroup_ACW1"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_J8qt" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sp2o"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_AUya"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这里我们在 <code>location /bar</code> 中用 set 指令创建了变量 <code>$foo</code>，于是<strong>在整个配置文件中这个变量都是可见的</strong>，因此我们可以在 location /foo 中直接引用这个变量而不用担心 Nginx 会报错。</p><p>下面是在命令行上用 curl 工具访问这两个接口的结果：</p><div class="codeBlockContainer_wGwY theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_S5yK"><pre tabindex="0" class="prism-code language-text codeBlock_DhuE thin-scrollbar"><code class="codeBlockLines_dNfr"><span class="token-line" style="color:#393A34"><span class="token plain">$ curl &#x27;http://localhost:8080/foo&#x27;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">foo = []  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ curl &#x27;http://localhost:8080/bar&#x27;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">foo = [32]  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ curl &#x27;http://localhost:8080/foo&#x27;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">foo = [] </span><br></span></code></pre><div class="buttonGroup_ACW1"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_J8qt" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sp2o"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_AUya"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>从这个例子我们可以看到，set 指令因为是在 <code>location /bar</code> 中使用的，所以<strong>赋值操作只会在访问 /bar 的请求中执行</strong>。而请求 <code>/foo</code> 接口时，我们总是得到空的 $foo 值，因为<strong>用户变量未赋值就输出的话，得到的便是空字符串</strong>。</p><p>从这个例子我们可以窥见的另一个重要特性是，<strong>Nginx 变量名的可见范围虽然是整个配置，但每个请求都有所有变量的独立副本，或者说都有各变量用来存放值的容器的独立副本，彼此互不干扰</strong>。比如前面我们请求了 <code>/bar</code> 接口后，<code>$foo</code> 变量被赋予了值 32，但它丝毫不会影响后续对 <code>/foo</code> 接口的请求所对应的 $foo 值（<strong>它仍然是空的！</strong>），因为各个请求都有自己独立的 $foo 变量的副本。
对于 Nginx 新手来说，最常见的错误之一，就是将 Nginx 变量理解成某种在请求之间全局共享的东西，或者说“全局变量”。而事实上，Nginx 变量的生命期是不可能跨越请求边界的。</p><p>关于 nginx 变量的另一个常见误区是认为变量容器的生命期，是与 <code>location</code> 配置块绑定的。</p><p>其实不然,我们来看一个涉及“内部跳转”的例子：</p><div class="codeBlockContainer_wGwY theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_S5yK"><pre tabindex="0" class="prism-code language-text codeBlock_DhuE thin-scrollbar"><code class="codeBlockLines_dNfr"><span class="token-line" style="color:#393A34"><span class="token plain">server {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  listen 8080;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  location /foo {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    set $a hello;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    echo_exec /bar;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  location /bar {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    echo &quot;a = [$a]&quot;;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span><br></span></code></pre><div class="buttonGroup_ACW1"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_J8qt" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sp2o"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_AUya"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这里我们在 location /foo 中，使用第三方模块 <code>ngx_echo</code> 提供的 <code>echo_exec</code> 配置指令，发起到 <code>location /bar</code> 的“内部跳转”。所谓“内部跳转”，就是在处理请求的过程中，于服务器内部，<em>从一个 <code>location</code> 跳转到另一个 <code>location</code> 的过程</em>。这不同于利用 HTTP 状态码 301 和 302 所进行的“外部跳转”，因为后者是由 HTTP 客户端配合进行跳转的，而且在客户端，用户可以通过浏览器地址栏这样的界面，看到请求的 URL 地址发生了变化。内部跳转和 Bourne shell（或 Bash）中的 exec 命令很像，都是“有去无回”。另一个相近的例子是 C 语言中的 goto 语句。
既然是内部跳转，当前正在处理的请求就还是原来那个，只是当前的 <code>location</code> 发生了变化，所以还是原来的那一套 nginx 变量的容器副本。对应到上例，如果我们请求的是 /foo 这个接口，那么整个工作流程是这样的：</p><ul><li>先在 location /foo 中通过 set 指令将 $a 变量的值赋为字符串 hello，</li><li>然后通过 echo_exec 指令发起内部跳转，</li><li>又进入到 <code>location /bar</code> 中，</li><li>再输出 $a 变量的值。</li></ul><p>因为 $a 还是原来的 $a，所以我们可以期望得到 hello 这行输出。测试证实了这一点：</p><div class="codeBlockContainer_wGwY theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_S5yK"><pre tabindex="0" class="prism-code language-text codeBlock_DhuE thin-scrollbar"><code class="codeBlockLines_dNfr"><span class="token-line" style="color:#393A34"><span class="token plain">$ curl localhost:8080/foo  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">a = [hello] </span><br></span></code></pre><div class="buttonGroup_ACW1"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_J8qt" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sp2o"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_AUya"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>但如果我们从客户端直接访问 <code>/bar</code> 接口，就会得到空的 <code>$a</code> 变量的值，因为它依赖于 <code>location /foo</code> 来对 $a 进行初始化。从上面这个例子我们看到，<strong>一个请求在其处理过程中，即使经历多个不同的 location 配置块，它使用的还是同一套 Nginx 变量的副本</strong>。这里，我们也首次涉及到了“内部跳转”这个概念。
值得一提的是，标准 <code>ngx_rewrite</code> 模块的 rewrite 配置指令其实也可以发起“内部跳转”，例如上面那个例子用 rewrite 配置指令可以改写成下面这样的形式：</p><div class="codeBlockContainer_wGwY theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_S5yK"><pre tabindex="0" class="prism-code language-text codeBlock_DhuE thin-scrollbar"><code class="codeBlockLines_dNfr"><span class="token-line" style="color:#393A34"><span class="token plain">server {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  listen 8080;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  location /foo {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    set $a hello;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    rewrite ^ /bar;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  location /bar {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    echo &quot;a = [$a]&quot;;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_ACW1"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_J8qt" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sp2o"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_AUya"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>其效果和使用 echo_exec 是完全相同的。后面我们还会专门介绍这个 rewrite 指令的更多用法，比如发起 301 和 302 这样的“外部跳转”。从上面这个例子我们看到，Nginx 变量值容器的生命期是与当前正在处理的请求绑定的，而与 location 无关。前面我们接触到的都是通过 set 指令隐式创建的 Nginx 变量。这些变量我们一般称为“用户自定义变量”，或者更简单一些，“用户变量”。既然有“用户自定义变量”，自然也就有由 Nginx 核心和各个 Nginx 模块提供的“预定义变量”，或者说“内建变量”（builtin variables）。</p><h2 class="anchor anchorWithHideOnScrollNavbar_vLxx" id="nginx-内建变量">Nginx 内建变量<a href="#nginx-内建变量" class="hash-link" aria-label="Nginx 内建变量的直接链接" title="Nginx 内建变量的直接链接">​</a></h2><p>Nginx 内建变量最常见的用途就是获取关于请求或响应的各种信息。例如由 ngx_http_core 模块提供的内建变量 $uri，可以用来获取当前请求的 URI（经过解码，并且不含请求参数），而 $request_uri 则用来获取请求最原始的 URI （未经解码，并且包含请求参数）。请看下面这个例子：</p><div class="codeBlockContainer_wGwY theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_S5yK"><pre tabindex="0" class="prism-code language-text codeBlock_DhuE thin-scrollbar"><code class="codeBlockLines_dNfr"><span class="token-line" style="color:#393A34"><span class="token plain">location /test {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  echo &quot;uri = $uri&quot;;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  echo &quot;request_uri = $request_uri&quot;;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span><br></span></code></pre><div class="buttonGroup_ACW1"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_J8qt" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sp2o"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_AUya"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这里为了简单起见，连 server 配置块也省略了，和前面所有示例一样，我们监听的依然是 8080 端口。在这个例子里，我们把 $uri 和 $request_uri 的值输出到响应体中去。下面我们用不同的请求来测试一下这个 /test 接口：</p><div class="codeBlockContainer_wGwY theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_S5yK"><pre tabindex="0" class="prism-code language-text codeBlock_DhuE thin-scrollbar"><code class="codeBlockLines_dNfr"><span class="token-line" style="color:#393A34"><span class="token plain">$ curl &#x27;http://localhost:8080/test&#x27;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">uri = /test  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">request_uri = /test  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ curl &#x27;http://localhost:8080/test?a=3&amp;b=4&#x27;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">uri = /test  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">request_uri = /test?a=3&amp;b=4 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ curl &#x27;http://localhost:8080/test/hello%20world?a=3&amp;b=4&#x27;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">uri = /test/hello world  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">request_uri = /test/hello%20world?a=3&amp;b=4 </span><br></span></code></pre><div class="buttonGroup_ACW1"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_J8qt" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sp2o"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_AUya"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>另一个特别常用的内建变量其实并不是单独一个变量，而是有无限多变种的一群变量，即名字以 arg_ 开头的所有变量，我们估且称之为 $arg_XXX 变量群。一个例子是 $arg_name，这个变量的值是当前请求名为 name 的 URI 参数的值，而且还是未解码的原始形式的值。我们来看一个比较完整的示例：</p><div class="codeBlockContainer_wGwY theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_S5yK"><pre tabindex="0" class="prism-code language-text codeBlock_DhuE thin-scrollbar"><code class="codeBlockLines_dNfr"><span class="token-line" style="color:#393A34"><span class="token plain">location /test {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  echo &quot;name: $arg_name&quot;;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  echo &quot;class: $arg_class&quot;;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span><br></span></code></pre><div class="buttonGroup_ACW1"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_J8qt" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sp2o"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_AUya"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>然后在命令行上使用各种参数组合去请求这个 /test 接口：</p><div class="codeBlockContainer_wGwY theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_S5yK"><pre tabindex="0" class="prism-code language-text codeBlock_DhuE thin-scrollbar"><code class="codeBlockLines_dNfr"><span class="token-line" style="color:#393A34"><span class="token plain">$ curl &#x27;http://localhost:8080/test&#x27;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">name:  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class:  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ curl &#x27;http://localhost:8080/test?name=Tom&amp;class=3&#x27;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">name: Tom  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class: 3 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ curl &#x27;http://localhost:8080/test?name=hello%20world&amp;class=9&#x27;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">name: hello%20world  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class: 9 </span><br></span></code></pre><div class="buttonGroup_ACW1"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_J8qt" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sp2o"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_AUya"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>其实 $arg_name 不仅可以匹配 name 参数，也可以匹配 NAME 参数，抑或是 Name，等等：</p><div class="codeBlockContainer_wGwY theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_S5yK"><pre tabindex="0" class="prism-code language-text codeBlock_DhuE thin-scrollbar"><code class="codeBlockLines_dNfr"><span class="token-line" style="color:#393A34"><span class="token plain">$ curl &#x27;http://localhost:8080/test?NAME=Marry&#x27;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">name: Marry  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class:  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ curl &#x27;http://localhost:8080/test?Name=Jimmy&#x27;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">name: Jimmy  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class: </span><br></span></code></pre><div class="buttonGroup_ACW1"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_J8qt" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sp2o"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_AUya"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><blockquote><p>Nginx 会在匹配参数名之前，自动把原始请求中的参数名调整为全部小写的形式。</p></blockquote><p>如果你想对 URI 参数值中的 <code>%XX</code> 这样的编码序列进行解码，可以使用第三方 <code>ngx_set_misc</code> 模块提供的 <code>set_unescape_uri</code> 配置指令：</p><div class="codeBlockContainer_wGwY theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_S5yK"><pre tabindex="0" class="prism-code language-text codeBlock_DhuE thin-scrollbar"><code class="codeBlockLines_dNfr"><span class="token-line" style="color:#393A34"><span class="token plain">location /test {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  set_unescape_uri $name $arg_name;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  set_unescape_uri $class $arg_class;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  echo &quot;name: $name&quot;;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  echo &quot;class: $class&quot;;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span><br></span></code></pre><div class="buttonGroup_ACW1"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_J8qt" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sp2o"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_AUya"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>现在我们再看一下效果：</p><div class="codeBlockContainer_wGwY theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_S5yK"><pre tabindex="0" class="prism-code language-text codeBlock_DhuE thin-scrollbar"><code class="codeBlockLines_dNfr"><span class="token-line" style="color:#393A34"><span class="token plain">$ curl &#x27;http://localhost:8080/test?name=hello%20world&amp;class=9&#x27;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">name: hello world  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class: 9 </span><br></span></code></pre><div class="buttonGroup_ACW1"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_J8qt" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sp2o"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_AUya"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>空格果然被解码出来了！
从这个例子我们同时可以看到，这个 <code>set_unescape_uri</code> 指令也像 set 指令那样，拥有自动创建 Nginx 变量的功能。后面我们还会专门介绍到 ngx_set_misc 模块。像 <code>$arg_XXX</code> 这种类型的变量拥有无穷无尽种可能的名字，所以它们并不对应任何存放值的容器。而且这种变量在 Nginx 核心中是经过特别处理的，第三方 Nginx 模块是不能提供这样充满魔法的内建变量的。</p><blockquote><p>类似 <code>$arg_XXX</code> 的内建变量还有不少，比如用来取 cookie 值的 <code>$cookie_XXX</code> 变量群，用来取请求头的 <code>$http_XXX</code> 变量群，以及用来取响应头的 <code>$sent_http_XXX</code> 变量群。这里就不一一介绍了，感兴趣的读者可以参考 ngx_http_core 模块的官方文档。需要指出的是，许多内建变量都是只读的，比如我们刚才介绍的 <code>$uri</code> 和 <code>$request_uri</code>. 对只读变量进行赋值是应当绝对避免的，因为会有意想不到的后果，比如：</p></blockquote><div class="codeBlockContainer_wGwY theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_S5yK"><pre tabindex="0" class="prism-code language-text codeBlock_DhuE thin-scrollbar"><code class="codeBlockLines_dNfr"><span class="token-line" style="color:#393A34"><span class="token plain">location /bad {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  set $uri /blah;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  echo $uri;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> } </span><br></span></code></pre><div class="buttonGroup_ACW1"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_J8qt" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sp2o"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_AUya"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这个有问题的配置会让 Nginx 在启动的时候报出一条令人匪夷所思的错误：</p><div class="codeBlockContainer_wGwY theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_S5yK"><pre tabindex="0" class="prism-code language-text codeBlock_DhuE thin-scrollbar"><code class="codeBlockLines_dNfr"><span class="token-line" style="color:#393A34"><span class="token plain">[emerg] the duplicate &quot;uri&quot; variable in ... </span><br></span></code></pre><div class="buttonGroup_ACW1"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_J8qt" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sp2o"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_AUya"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><blockquote><p>如果你尝试改写另外一些只读的内建变量，比如 $arg_XXX 变量，在某些 Nginx 的版本中甚至可能导致进程崩溃。</p></blockquote><p>也有一些内建变量是支持改写的，其中一个例子是 $args. 这个变量在读取时返回当前请求的 URL 参数串（即请求 URL 中问号后面的部分，如果有的话 ），而在赋值时可以直接修改参数串。我们来看一个例子：</p><div class="codeBlockContainer_wGwY theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_S5yK"><pre tabindex="0" class="prism-code language-text codeBlock_DhuE thin-scrollbar"><code class="codeBlockLines_dNfr"><span class="token-line" style="color:#393A34"><span class="token plain">location /test {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  set $orig_args $args;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  set $args &quot;a=3&amp;b=4&quot;;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  echo &quot;original args: $orig_args&quot;;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  echo &quot;args: $args&quot;;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span><br></span></code></pre><div class="buttonGroup_ACW1"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_J8qt" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sp2o"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_AUya"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这里我们把原始的 URL 参数串先保存在 $orig_args 变量中，然后通过改写 $args 变量来修改当前的 URL 参数串，最后我们用 echo 指令分别输出 $orig_args 和 $args 变量的值。接下来我们这样来测试这个 /test 接口：</p><div class="codeBlockContainer_wGwY theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_S5yK"><pre tabindex="0" class="prism-code language-text codeBlock_DhuE thin-scrollbar"><code class="codeBlockLines_dNfr"><span class="token-line" style="color:#393A34"><span class="token plain">$ curl &#x27;http://localhost:8080/test&#x27;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">original args:  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">args: a=3&amp;b=4 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ curl &#x27;http://localhost:8080/test?a=0&amp;b=1&amp;c=2&#x27;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">original args: a=0&amp;b=1&amp;c=2 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">args: a=3&amp;b=4 </span><br></span></code></pre><div class="buttonGroup_ACW1"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_J8qt" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sp2o"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_AUya"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在第一次测试中，我们没有设置任何 URL 参数串，所以输出 <code>$orig_args</code> 变量的值时便得到空。而在第一次和第二次测试中，无论我们是否提供 URL 参数串，参数串都会在 location /test 中被强行改写成 a=3&amp;b=4.
需要特别指出的是，这里的 $args 变量和 $arg_XXX 一样，也不再使用属于自己的存放值的容器。当我们读取 $args 时，nginx 会执行一小段代码，从 Nginx 核心中专门存放当前 URL 参数串的位置去读取数据；而当我们改写 $args 时，Nginx 会执行另一小段代码，对相同位置进行改写。Nginx 的其他部分在需要当前 URL 参数串的时候，都会从那个位置去读数据，所以我们对 $args 的修改会影响到所有部分的功能。我们来看一个例子：</p><div class="codeBlockContainer_wGwY theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_S5yK"><pre tabindex="0" class="prism-code language-text codeBlock_DhuE thin-scrollbar"><code class="codeBlockLines_dNfr"><span class="token-line" style="color:#393A34"><span class="token plain">location /test {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  set $orig_a $arg_a;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  set $args &quot;a=5&quot;;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  echo &quot;original a: $orig_a&quot;;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  echo &quot;a: $arg_a&quot;;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span><br></span></code></pre><div class="buttonGroup_ACW1"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_J8qt" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sp2o"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_AUya"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这里我们先把内建变量 $arg_a 的值，即原始请求的 URL 参数 a 的值，保存在用户变量 $orig_a 中，然后通过对内建变量 $args 进行赋值，把当前请求的参数串改写为 a=5 ，最后再用 echo 指令分别输出 $orig_a 和 $arg_a 变量的值。因为对内建变量 $args 的修改会直接导致当前请求的 URL 参数串发生变化，因此内建变量 $arg_XXX 自然也会随之变化。测试的结果证实了这一点：</p><div class="codeBlockContainer_wGwY theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_S5yK"><pre tabindex="0" class="prism-code language-text codeBlock_DhuE thin-scrollbar"><code class="codeBlockLines_dNfr"><span class="token-line" style="color:#393A34"><span class="token plain">$ curl &#x27;http://localhost:8080/test?a=3&#x27;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">original a: 3 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">a: 5 </span><br></span></code></pre><div class="buttonGroup_ACW1"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_J8qt" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sp2o"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_AUya"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>我们看到，因为原始请求的 URL 参数串是 a=3, 所以 $arg_a 最初的值为 3, 但随后通过改写 $args 变量，将 URL 参数串又强行修改为 a=5, 所以最终 $arg_a 的值又自动变为了 5.我们再来看一个通过修改 $args 变量影响标准的 HTTP 代理模块 ngx_proxy 的例子：</p><div class="codeBlockContainer_wGwY theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_S5yK"><pre tabindex="0" class="prism-code language-text codeBlock_DhuE thin-scrollbar"><code class="codeBlockLines_dNfr"><span class="token-line" style="color:#393A34"><span class="token plain">server {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  listen 8080;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  location /test {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    set $args &quot;foo=1&amp;bar=2&quot;;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    proxy_pass http://127.0.0.1:8081/args;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">server {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  listen 8081;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  location /args {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    echo &quot;args: $args&quot;;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_ACW1"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_J8qt" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sp2o"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_AUya"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这里我们在 http 配置块中定义了两个虚拟主机。第一个虚拟主机监听 8080 端口，其 /test 接口自己通过改写 $args 变量，将当前请求的 URL 参数串无条件地修改为 foo=1&amp;bar=2. 然后 /test 接口再通过 ngx_proxy 模块的 proxy_pass 指令配置了一个反向代理，指向本机的 8081 端口上的 HTTP 服务 /args. 默认情况下，ngx_proxy 模块在转发 HTTP 请求到远方 HTTP 服务的时候，会自动把当前请求的 URL 参数串也转发到远方。而本机的 8081 端口上的 HTTP 服务正是由我们定义的第二个虚拟主机来提供的。我们在第二个虚拟主机的 location /args 中利用 echo 指令输出当前请求的 URL 参数串，以检查 /test 接口通过 ngx_proxy 模块实际转发过来的 URL 请求参数串。我们来实际访问一下第一个虚拟主机的 /test 接口：</p><div class="codeBlockContainer_wGwY theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_S5yK"><pre tabindex="0" class="prism-code language-text codeBlock_DhuE thin-scrollbar"><code class="codeBlockLines_dNfr"><span class="token-line" style="color:#393A34"><span class="token plain">$ curl &#x27;http://localhost:8080/test?blah=7&#x27;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">args: foo=1&amp;bar=2 </span><br></span></code></pre><div class="buttonGroup_ACW1"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_J8qt" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_sp2o"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_AUya"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>我们看到，虽然请求自己提供了 URL 参数串 blah=7，但在 location /test 中，参数串被强行改写成了 foo=1&amp;bar=2. 接着经由 proxy_pass 指令将我们被改写掉的参数串转发给了第二个虚拟主机上配置的 /args 接口，然后再把 /args 接口的 URL 参数串输出。事实证明，我们对 $args 变量的赋值操作，也成功影响到了 ngx_proxy 模块的行为。
在读取变量时执行的这段特殊代码，在 Nginx 中被称为“取处理程序”（get handler）；而改写变量时执行的这段特殊代码，则被称为“存处理程序”（set handler）。不同的 Nginx 模块一般会为它们的变量准备不同的“存取处理程序”，从而让这些变量的行为充满魔法。其实这种技巧在计算世界并不鲜见。比如在面向对象编程中，类的设计者一般不会把类的成员变量直接暴露给类的用户，而是另行提供两个方法（method），分别用于该成员变量的读操作和写操作，这两个方法常常被称为“存取器”（accessor）。</p><blockquote><p>转自：<a href="http://www.jb51.net/article/77593.htm" target="_blank" rel="noopener noreferrer">浅析Nginx配置文件中的变量的编写使用</a></p></blockquote><p>更多nginx内置变量请看 <a href="/blog/nginx-built-in-vars-refers">nginx内置变量大全</a></p></div><footer class="row docusaurus-mt-lg blogPostFooterDetailsFull_GP_3"><div class="col"><b>标签：</b><ul class="tags_Dgru padding--none margin-left--sm"><li class="tag_omUF"><a class="tag_plK1 tagRegular_SSGO" href="/blog/tags/ngnix">ngnix</a></li></ul></div><div class="col margin-top--sm"><a href="https://github.com/inhere/inhere.github.io/tree/main/blog/2016/05-13-custom-vars-usage-in-ngnix-config.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Y1Rf" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="博文分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/scripts-in-php-composer-json"><div class="pagination-nav__sublabel">较新一篇</div><div class="pagination-nav__label">composer.json 中的 scripts 脚本</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/nginx-built-in-vars-refers"><div class="pagination-nav__sublabel">较旧一篇</div><div class="pagination-nav__label">Nginx内置变量大全</div></a></nav></main><div class="col col--2"><div class="tableOfContents_j2oJ thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#nginx-用户变量" class="table-of-contents__link toc-highlight">Nginx 用户变量</a></li><li><a href="#nginx-内建变量" class="table-of-contents__link toc-highlight">Nginx 内建变量</a></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Docs</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/inhere" target="_blank" rel="noopener noreferrer" class="footer__link-item">Inhere GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_xZoC"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://github.com/gookit" target="_blank" rel="noopener noreferrer" class="footer__link-item">Gookit GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_xZoC"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://github.com/phppkg" target="_blank" rel="noopener noreferrer" class="footer__link-item">PHPPkg GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_xZoC"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a class="footer__link-item" href="/blog/tags">Blog Tags</a></li><li class="footer__item"><a class="footer__link-item" href="/blog/archive">Blog Archives</a></li><li class="footer__item"><a href="https://github.com/inhere/inhere.github.io" target="_blank" rel="noopener noreferrer" class="footer__link-item">Site GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_xZoC"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 My Project, Inc.
         Built with <a target="block" href="https://github.com/facebook/docusaurus">Docusaurus</a>.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.bfcef8ca.js"></script>
<script src="/assets/js/main.616ec195.js"></script>
</body>
</html>